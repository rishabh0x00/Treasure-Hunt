{
  "language": "Solidity",
  "sources": {
    "@chainlink/contracts/src/v0.8/shared/interfaces/LinkTokenInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// solhint-disable-next-line interface-starts-with-i\ninterface LinkTokenInterface {\n  function allowance(address owner, address spender) external view returns (uint256 remaining);\n\n  function approve(address spender, uint256 value) external returns (bool success);\n\n  function balanceOf(address owner) external view returns (uint256 balance);\n\n  function decimals() external view returns (uint8 decimalPlaces);\n\n  function decreaseApproval(address spender, uint256 addedValue) external returns (bool success);\n\n  function increaseApproval(address spender, uint256 subtractedValue) external;\n\n  function name() external view returns (string memory tokenName);\n\n  function symbol() external view returns (string memory tokenSymbol);\n\n  function totalSupply() external view returns (uint256 totalTokensIssued);\n\n  function transfer(address to, uint256 value) external returns (bool success);\n\n  function transferAndCall(address to, uint256 value, bytes calldata data) external returns (bool success);\n\n  function transferFrom(address from, address to, uint256 value) external returns (bool success);\n}\n"
    },
    "@chainlink/contracts/src/v0.8/vrf/dev/interfaces/IVRFV2PlusWrapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IVRFV2PlusWrapper {\n  /**\n   * @return the request ID of the most recent VRF V2 request made by this wrapper. This should only\n   * be relied option within the same transaction that the request was made.\n   */\n  function lastRequestId() external view returns (uint256);\n\n  /**\n   * @notice Calculates the price of a VRF request with the given callbackGasLimit at the current\n   * @notice block.\n   *\n   * @dev This function relies on the transaction gas price which is not automatically set during\n   * @dev simulation. To estimate the price at a specific gas price, use the estimatePrice function.\n   *\n   * @param _callbackGasLimit is the gas limit used to estimate the price.\n   * @param _numWords is the number of words to request.\n   */\n  function calculateRequestPrice(uint32 _callbackGasLimit, uint32 _numWords) external view returns (uint256);\n\n  /**\n   * @notice Calculates the price of a VRF request in native with the given callbackGasLimit at the current\n   * @notice block.\n   *\n   * @dev This function relies on the transaction gas price which is not automatically set during\n   * @dev simulation. To estimate the price at a specific gas price, use the estimatePrice function.\n   *\n   * @param _callbackGasLimit is the gas limit used to estimate the price.\n   * @param _numWords is the number of words to request.\n   */\n  function calculateRequestPriceNative(uint32 _callbackGasLimit, uint32 _numWords) external view returns (uint256);\n\n  /**\n   * @notice Estimates the price of a VRF request with a specific gas limit and gas price.\n   *\n   * @dev This is a convenience function that can be called in simulation to better understand\n   * @dev pricing.\n   *\n   * @param _callbackGasLimit is the gas limit used to estimate the price.\n   * @param _numWords is the number of words to request.\n   * @param _requestGasPriceWei is the gas price in wei used for the estimation.\n   */\n  function estimateRequestPrice(\n    uint32 _callbackGasLimit,\n    uint32 _numWords,\n    uint256 _requestGasPriceWei\n  ) external view returns (uint256);\n\n  /**\n   * @notice Estimates the price of a VRF request in native with a specific gas limit and gas price.\n   *\n   * @dev This is a convenience function that can be called in simulation to better understand\n   * @dev pricing.\n   *\n   * @param _callbackGasLimit is the gas limit used to estimate the price.\n   * @param _numWords is the number of words to request.\n   * @param _requestGasPriceWei is the gas price in wei used for the estimation.\n   */\n  function estimateRequestPriceNative(\n    uint32 _callbackGasLimit,\n    uint32 _numWords,\n    uint256 _requestGasPriceWei\n  ) external view returns (uint256);\n\n  /**\n   * @notice Requests randomness from the VRF V2 wrapper, paying in native token.\n   *\n   * @param _callbackGasLimit is the gas limit for the request.\n   * @param _requestConfirmations number of request confirmations to wait before serving a request.\n   * @param _numWords is the number of words to request.\n   */\n  function requestRandomWordsInNative(\n    uint32 _callbackGasLimit,\n    uint16 _requestConfirmations,\n    uint32 _numWords,\n    bytes calldata extraArgs\n  ) external payable returns (uint256 requestId);\n\n  function link() external view returns (address);\n  function linkNativeFeed() external view returns (address);\n}\n"
    },
    "@chainlink/contracts/src/v0.8/vrf/dev/libraries/VRFV2PlusClient.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n// End consumer library.\nlibrary VRFV2PlusClient {\n  // extraArgs will evolve to support new features\n  bytes4 public constant EXTRA_ARGS_V1_TAG = bytes4(keccak256(\"VRF ExtraArgsV1\"));\n  struct ExtraArgsV1 {\n    bool nativePayment;\n  }\n\n  struct RandomWordsRequest {\n    bytes32 keyHash;\n    uint256 subId;\n    uint16 requestConfirmations;\n    uint32 callbackGasLimit;\n    uint32 numWords;\n    bytes extraArgs;\n  }\n\n  function _argsToBytes(ExtraArgsV1 memory extraArgs) internal pure returns (bytes memory bts) {\n    return abi.encodeWithSelector(EXTRA_ARGS_V1_TAG, extraArgs);\n  }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/vrf/dev/VRFV2PlusWrapperConsumerBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {LinkTokenInterface} from \"../../shared/interfaces/LinkTokenInterface.sol\";\nimport {IVRFV2PlusWrapper} from \"./interfaces/IVRFV2PlusWrapper.sol\";\n\n/**\n *\n * @notice Interface for contracts using VRF randomness through the VRF V2 wrapper\n * ********************************************************************************\n * @dev PURPOSE\n *\n * @dev Create VRF V2+ requests without the need for subscription management. Rather than creating\n * @dev and funding a VRF V2+ subscription, a user can use this wrapper to create one off requests,\n * @dev paying up front rather than at fulfillment.\n *\n * @dev Since the price is determined using the gas price of the request transaction rather than\n * @dev the fulfillment transaction, the wrapper charges an additional premium on callback gas\n * @dev usage, in addition to some extra overhead costs associated with the VRFV2Wrapper contract.\n * *****************************************************************************\n * @dev USAGE\n *\n * @dev Calling contracts must inherit from VRFV2PlusWrapperConsumerBase. The consumer must be funded\n * @dev with enough LINK or ether to make the request, otherwise requests will revert. To request randomness,\n * @dev call the 'requestRandomWords' function with the desired VRF parameters. This function handles\n * @dev paying for the request based on the current pricing.\n *\n * @dev Consumers must implement the fullfillRandomWords function, which will be called during\n * @dev fulfillment with the randomness result.\n */\nabstract contract VRFV2PlusWrapperConsumerBase {\n  error OnlyVRFWrapperCanFulfill(address have, address want);\n\n  LinkTokenInterface internal immutable i_linkToken;\n  IVRFV2PlusWrapper public immutable i_vrfV2PlusWrapper;\n\n  /**\n   * @param _vrfV2PlusWrapper is the address of the VRFV2Wrapper contract\n   */\n  constructor(address _vrfV2PlusWrapper) {\n    IVRFV2PlusWrapper vrfV2PlusWrapper = IVRFV2PlusWrapper(_vrfV2PlusWrapper);\n\n    i_linkToken = LinkTokenInterface(vrfV2PlusWrapper.link());\n    i_vrfV2PlusWrapper = vrfV2PlusWrapper;\n  }\n\n  /**\n   * @dev Requests randomness from the VRF V2+ wrapper.\n   *\n   * @param _callbackGasLimit is the gas limit that should be used when calling the consumer's\n   *        fulfillRandomWords function.\n   * @param _requestConfirmations is the number of confirmations to wait before fulfilling the\n   *        request. A higher number of confirmations increases security by reducing the likelihood\n   *        that a chain re-org changes a published randomness outcome.\n   * @param _numWords is the number of random words to request.\n   *\n   * @return requestId is the VRF V2+ request ID of the newly created randomness request.\n   */\n  // solhint-disable-next-line chainlink-solidity/prefix-internal-functions-with-underscore\n  function requestRandomness(\n    uint32 _callbackGasLimit,\n    uint16 _requestConfirmations,\n    uint32 _numWords,\n    bytes memory extraArgs\n  ) internal returns (uint256 requestId, uint256 reqPrice) {\n    reqPrice = i_vrfV2PlusWrapper.calculateRequestPrice(_callbackGasLimit, _numWords);\n    i_linkToken.transferAndCall(\n      address(i_vrfV2PlusWrapper),\n      reqPrice,\n      abi.encode(_callbackGasLimit, _requestConfirmations, _numWords, extraArgs)\n    );\n    return (i_vrfV2PlusWrapper.lastRequestId(), reqPrice);\n  }\n\n  // solhint-disable-next-line chainlink-solidity/prefix-internal-functions-with-underscore\n  function requestRandomnessPayInNative(\n    uint32 _callbackGasLimit,\n    uint16 _requestConfirmations,\n    uint32 _numWords,\n    bytes memory extraArgs\n  ) internal returns (uint256 requestId, uint256 requestPrice) {\n    requestPrice = i_vrfV2PlusWrapper.calculateRequestPriceNative(_callbackGasLimit, _numWords);\n    return (\n      i_vrfV2PlusWrapper.requestRandomWordsInNative{value: requestPrice}(\n        _callbackGasLimit,\n        _requestConfirmations,\n        _numWords,\n        extraArgs\n      ),\n      requestPrice\n    );\n  }\n\n  /**\n   * @notice fulfillRandomWords handles the VRF V2 wrapper response. The consuming contract must\n   * @notice implement it.\n   *\n   * @param _requestId is the VRF V2 request ID.\n   * @param _randomWords is the randomness result.\n   */\n  // solhint-disable-next-line chainlink-solidity/prefix-internal-functions-with-underscore\n  function fulfillRandomWords(uint256 _requestId, uint256[] memory _randomWords) internal virtual;\n\n  function rawFulfillRandomWords(uint256 _requestId, uint256[] memory _randomWords) external {\n    address vrfWrapperAddr = address(i_vrfV2PlusWrapper);\n    if (msg.sender != vrfWrapperAddr) {\n      revert OnlyVRFWrapperCanFulfill(msg.sender, vrfWrapperAddr);\n    }\n    fulfillRandomWords(_requestId, _randomWords);\n  }\n\n  /// @notice getBalance returns the native balance of the consumer contract\n  function getBalance() public view returns (uint256) {\n    return address(this).balance;\n  }\n\n  /// @notice getLinkToken returns the link token contract\n  function getLinkToken() public view returns (LinkTokenInterface) {\n    return i_linkToken;\n  }\n}\n"
    },
    "contracts/TreasureHunt.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity =0.8.24;\n\nimport {VRFV2PlusWrapperConsumerBase} from \"@chainlink/contracts/src/v0.8/vrf/dev/VRFV2PlusWrapperConsumerBase.sol\";\nimport {VRFV2PlusClient} from \"@chainlink/contracts/src/v0.8/vrf/dev/libraries/VRFV2PlusClient.sol\";\n/**\n * @title TreasureHunt\n * @dev A game contract where players participate in a treasure hunt, with position moves and treasure location updates.\n */\n\ncontract TreasureHunt is VRFV2PlusWrapperConsumerBase {\n    // Enum representing possible move directions\n    enum Directions {\n        Left,\n        Right,\n        Top,\n        Bottom\n    }\n\n    enum TreasureMove {\n        MultipleOfFive,\n        PrimeNumber\n    }\n\n    struct Game {\n        uint8 treasurePosition;\n        bool treasureMoving; // players cannont play when treasure is moving\n        uint40 startTime;\n        address winner;\n        uint256 tvl;\n        uint256 playerCount;\n    }\n\n    struct Player {\n        uint8 position;\n        bool isActive;\n    }\n\n    struct Request {\n        address player;\n        uint8 newPosition;\n        TreasureMove condition;\n        bool newGame;\n        uint256 requestId;\n    }\n\n    // Constants\n    /* Bitmap of prime numbers from 0 to 99\n     Each bit represents a number, 1 if prime, 0 if not\n     100 bits, so we use a uint128\n    */\n    uint256 private constant _PRIME_BITMASK = 0x20208828828208a20a08a28ac;\n    bytes private extraArgs;\n    uint32 private constant CALLBACK_GAS_LIMIT = 100000;\n    uint32 private constant _NUM_OF_RANDOM_WORDS = 1;\n    uint16 private immutable _REQUEST_CONFIRMATIONS;\n\n    // Public Variables\n    uint256 public currentGameIndex; // Current game round index\n    uint8 public constant GRID_SIZE = 100;\n    uint256 public constant PARTICIPATION_FEE = 0.1 ether;\n    uint256 public immutable GAME_DURATION;\n    uint256 public immutable MIN_IDLE_GAMES;\n    address public immutable DEPLOYER;\n    mapping(uint256 gameIndex => Game game) public games;\n    mapping(uint256 gameIndex => mapping(address userAddress => Player position)) public players;\n    Request public request;\n\n    // Events\n    event PlayerRegistered(address indexed player, uint256 currentGameIndex);\n    event PlayerMoved(address player, uint256 currentGameIndex, uint8 newPosition);\n    event TreasureMoved(uint8 indexed newPosition, uint256 currentGameIndex);\n    event GameWon(address indexed winner, uint256 prize, uint256 currentGameIndex);\n    event GameStarted(uint256 indexed currentGameIndex, uint256 initialTVL, uint8 initialTreasurePosition);\n    event GameExpired(uint256 indexed currentGameIndex);\n    event FundsWithdrawn(address indexed user);\n    event RequestSent(uint256 requestId);\n    event RequestFulfilled(uint256 requestId, uint256[] randomWords);\n    event Received(address indexed sender, uint256 amount);\n    event InactiveGamesTVLWithdrawn(address indexed withdrawer, uint256 amount);\n\n    // Custom Errors\n    error UserAlreadyRegistered(address user);\n    error WaitForNextTurn();\n    error InvalidMove(Directions move, uint8 currentPosition);\n    error GameNotExpired(uint256 currentGameIndex);\n    error GameNotActive(uint256 currentGameIndex);\n    error GameCannotBeExpired(uint256 currentGameIndex);\n    error ZeroAmountToWithdraw();\n    error CannotStartNewGame();\n    error InvalidExpiry();\n    error InvalidTurnDuration();\n    error InvalidParticipationFee();\n    error ErrorMovingTreasure();\n    error RequestNotFound(uint256 requestId);\n    error NoInactiveGameWithTVLToWithdraw();\n    error NotEnoughGamesPlayedYetToWithdrawTVL(uint256 currentGameIndex);\n    error NumberMustBeLessThanHundered();\n    error OnlyDeployerCanCall();\n\n    /**\n     * @dev Constructor to initialize the contract with minimum turn duration and expiry duration.\n     * @param _vrfV2PlusWrapper Address of chainlink vrfV2PlusWrapper contract on deployment chain\n     * @param _requestConfirmation The number of block confirmations the VRF service will wait to respond.\n     * @param _gameDuration Duration till the game lasts\n     * @param _inactiveGamesWithdrawTVLIndex Index count for inactive games for withdrawal of accumulated TVL\n     */\n    constructor(\n        address _vrfV2PlusWrapper,\n        uint16 _requestConfirmation,\n        uint256 _gameDuration,\n        uint256 _inactiveGamesWithdrawTVLIndex\n    ) VRFV2PlusWrapperConsumerBase(_vrfV2PlusWrapper) {\n        DEPLOYER = msg.sender;\n        currentGameIndex++;\n        games[currentGameIndex].startTime = uint40(block.timestamp);\n        uint8 initialTreasurePosition = _generateInitialRandomPosition();\n        games[currentGameIndex].treasurePosition = initialTreasurePosition;\n        _REQUEST_CONFIRMATIONS = _requestConfirmation;\n        GAME_DURATION = _gameDuration;\n        MIN_IDLE_GAMES = _inactiveGamesWithdrawTVLIndex;\n\n        emit GameStarted(currentGameIndex, games[currentGameIndex].tvl, initialTreasurePosition);\n        extraArgs = VRFV2PlusClient._argsToBytes(VRFV2PlusClient.ExtraArgsV1({nativePayment: true}));\n    }\n\n    // Modifiers\n\n    /**\n     * @dev Modifier to check if the game has expired.\n     */\n    modifier gameExpired(uint256 gameIndex) {\n        if (gameIndex >= currentGameIndex) {\n            revert GameNotExpired(currentGameIndex);\n        }\n        _;\n    }\n\n    // External functions\n\n    /**\n     * @dev Participate in the game by paying the participation fee.\n     * @notice The participant must send Ether to join the game.\n     * If the player has already registered for the current game round, the transaction will revert.\n     * Emits a {PlayerRegistered} event.\n     */\n    function participate() external payable {\n        if (msg.value != PARTICIPATION_FEE) {\n            revert InvalidParticipationFee();\n        }\n        address participant = msg.sender;\n\n        if (players[currentGameIndex][participant].isActive) {\n            revert UserAlreadyRegistered(participant);\n        }\n\n        games[currentGameIndex].playerCount++;\n        games[currentGameIndex].tvl += PARTICIPATION_FEE;\n        players[currentGameIndex][participant].isActive = true;\n\n        emit PlayerRegistered(participant, currentGameIndex);\n    }\n\n    /**\n     * @dev Allows a player to make a move in the specified direction.\n     * The player must wait for their turn before making a move.\n     * Updates the player's position and checks if the move results in winning the game.\n     * If the player wins, the game is ended; otherwise, the treasure's position is updated.\n     *\n     * Emits a {PlayerMoved} event when the player makes a move.\n     *\n     * @param move The direction in which the player wants to move. This should be one of the values from the `Directions` enum.\n     */\n    function play(Directions move) public payable {\n        uint256 _currentGameIndex = currentGameIndex;\n        Player memory _player = players[_currentGameIndex][msg.sender];\n        require(_player.isActive, \"INACTIVE player\");\n        Game memory _game = games[_currentGameIndex];\n        require(!_game.treasureMoving, \"Treasure is in movement\");\n        uint8 playerPosition = _player.position;\n        uint8 treasurePosition = _game.treasurePosition;\n\n        if (playerPosition == treasurePosition) {\n            _endGameAndProcessFunds(_currentGameIndex, msg.sender);\n        } else {\n            uint8 newPosition = _newPosition(playerPosition, move);\n\n            if (_isPrime(newPosition)) {\n                request.condition = TreasureMove.PrimeNumber;\n                request.player = msg.sender;\n                request.newPosition = newPosition;\n\n                _requestRandomWords(_currentGameIndex);\n            } else if (newPosition % 5 == 0) {\n                request.condition = TreasureMove.MultipleOfFive;\n                request.player = msg.sender;\n                request.newPosition = newPosition;\n\n                _requestRandomWords(_currentGameIndex);\n            } else {\n                players[_currentGameIndex][msg.sender].position = newPosition;\n                emit PlayerMoved(msg.sender, _currentGameIndex, newPosition);\n                if (newPosition == treasurePosition) {\n                    _endGameAndProcessFunds(_currentGameIndex, msg.sender);\n                }\n            }\n        }\n    }\n\n    /**\n     * @dev Expire the current game.\n     *\n     * Emits a {GameExpired} event.\n     *\n     * Reverts with:\n     * - `GameCannotBeExpired` if the current time is less than the game's expiry time.\n     */\n    function expireCurrentGame() external {\n        uint256 _currentGameIndex = currentGameIndex;\n        Game memory game = games[_currentGameIndex];\n        if (block.timestamp <= (game.startTime + GAME_DURATION)) {\n            revert GameCannotBeExpired(_currentGameIndex);\n        }\n\n        games[_currentGameIndex + 1].tvl = game.tvl - (game.playerCount * PARTICIPATION_FEE); // Remaining 10% stays for the next round\n\n        _startNewGame(_currentGameIndex);\n        emit GameExpired(_currentGameIndex);\n    }\n\n    /// @notice Allows withdrawal of TVL from inactive games\n    /// @dev This function checks for a series of inactive games and allows withdrawal of accumulated TVL\n    function withdrawInactiveGamesTVL() external {\n        if(msg.sender != DEPLOYER){\n            revert OnlyDeployerCanCall();\n        }\n        uint256 _currentGameIndex = currentGameIndex;\n\n        // Check if there are enough games played to allow withdrawal\n        if (_currentGameIndex < MIN_IDLE_GAMES) {\n            revert NotEnoughGamesPlayedYetToWithdrawTVL(_currentGameIndex);\n        }\n\n        Game memory currentGame = games[_currentGameIndex];\n\n        // Ensure the current game has expired\n        if (block.timestamp <= currentGame.startTime + GAME_DURATION) {\n            revert GameCannotBeExpired(_currentGameIndex);\n        }\n\n        uint256 startIndex = _currentGameIndex - MIN_IDLE_GAMES;\n\n        // Iterate through the range and ensure all games are inactive with non-zero TVL\n        for (uint256 i = startIndex; i <= _currentGameIndex; i++) {\n            // If any game in the range is not inactive with non-zero TVL, revert immediately\n            if (games[i].winner != address(0) || games[i].tvl == 0) {\n                revert NoInactiveGameWithTVLToWithdraw();\n            }\n        }\n\n        // Withdraw TVL of the current game to the caller\n        uint256 withdrawableTVL = currentGame.tvl;\n        payable(msg.sender).transfer(withdrawableTVL);\n        _startNewGame(_currentGameIndex);\n\n        emit InactiveGamesTVLWithdrawn(msg.sender, withdrawableTVL);\n    }\n\n    /**\n     * @dev Withdraw participation funds after the game has expired.\n     *\n     * Requirements:\n     * - The current game must be expired.\n     * - The caller must have a non-zero participation fee for the expired game.\n     *\n     * Emits a {FundsWithdrawn} event.\n     */\n    function withdrawFunds(uint256 gameIndex) external gameExpired(gameIndex) {\n        Player storage player = players[gameIndex][msg.sender];\n        if (!player.isActive) {\n            revert ZeroAmountToWithdraw();\n        }\n        player.isActive = false;\n        games[gameIndex].playerCount--;\n        games[gameIndex].tvl -= PARTICIPATION_FEE;\n        address payable receiver = payable(msg.sender);\n        receiver.transfer(PARTICIPATION_FEE);\n\n        emit FundsWithdrawn(receiver);\n    }\n\n    // Internal Functions\n\n    function _isPrime(uint8 number) internal pure returns (bool) {\n        if (number >= GRID_SIZE) {\n            revert NumberMustBeLessThanHundered();\n        }\n        return (_PRIME_BITMASK & (1 << number)) != 0;\n    }\n\n    /**\n     * @notice Handles the fulfillment of random words from the VRF (Verifiable Random Function) request.\n     * @dev This function is called by the VRFCoordinator when it receives the VRF response. It updates\n     *      the request status to fulfilled, stores the received random words, and emits an event.\n     *      Depending on the value of `resetTreasurePosition`, it either resets or moves the treasure's position.\n     * @param _requestId The unique identifier of the VRF request.\n     * @param _randomWords An array of random words provided by the VRF Coordinator.\n     */\n    function fulfillRandomWords(uint256 _requestId, uint256[] memory _randomWords) internal override {\n        uint256 _currentGameIndex = currentGameIndex;\n        games[_currentGameIndex].treasureMoving = false;\n        if (request.requestId != _requestId) {\n            revert RequestNotFound(_requestId);\n        }\n        if (request.newGame) {\n            _resetTreasurePosition(_randomWords[0]);\n        } else {\n            _moveTreasure(_randomWords[0]);\n\n            if (request.newPosition == games[_currentGameIndex].treasurePosition) {\n                _endGameAndProcessFunds(_currentGameIndex, request.player);\n            }\n        }\n        emit RequestFulfilled(_requestId, _randomWords);\n    }\n\n    /**\n     * @dev Moves the treasure based on the player's new position.\n     * The treasure's movement is determined by specific conditions:\n     * - If the player's current position is divisible by 5, the treasure will move to a random adjacent position.\n     * - If the treasure's current position is a prime number, it will move to a random position on the grid.\n     * Emits a `TreasureMoved` event after the treasure has moved.\n     */\n    function _moveTreasure(uint256 randomWord) internal {\n        if (request.condition == TreasureMove.MultipleOfFive) {\n            _moveToRandomAdjacentPosition(randomWord);\n        } else if (request.condition == TreasureMove.PrimeNumber) {\n            _moveToRandomPosition(randomWord);\n        }\n    }\n\n    /**\n     * @dev Handle the winning condition, transfer the reward to the winner, and reset the game.\n     * This function is triggered when a player lands on the treasure's position.\n     * It performs the following actions:\n     * - Sets the current player as the winner for the game.\n     * - Transfers 90% of the total balance as the reward to the winner.\n     * - Emits a `GameWon` event to announce the winner and the reward.\n     * - Calls `_resetGame` to start a new game round.\n     */\n    function _endGameAndProcessFunds(uint256 _currentGameIndex, address _winner) internal {\n        games[_currentGameIndex].winner = _winner;\n        uint256 reward = (games[_currentGameIndex].tvl * 9) / 10;\n        payable(_winner).transfer(reward);\n        games[_currentGameIndex + 1].tvl = address(this).balance; // Remaining 10% stays for the next round\n        emit GameWon(_winner, reward, _currentGameIndex);\n        _startNewGame(_currentGameIndex);\n    }\n\n    /**\n     * @dev Start a new game round.\n     * Increments the game index, sets the game as active, and moves the treasure to a new random position.\n     * The expiry time for the new game round is also set based on the expiry duration.\n     * Emits a `GameStarted` event with the new game index.\n     */\n    function _startNewGame(uint256 _currentGameIndex) internal {\n        currentGameIndex++;\n        games[currentGameIndex].startTime = uint40(block.timestamp);\n\n        request.newGame = true;\n        _requestRandomWords(_currentGameIndex);\n    }\n\n    /**\n     * @dev Moves the treasure to a random position on the grid.\n     * Ensures that the new position is neither the current position of the treasure\n     * nor the current position of the player.\n     */\n    function _moveToRandomPosition(uint256 randomWord) internal {\n        uint8 newTreasurePosition = uint8(randomWord % GRID_SIZE);\n        games[currentGameIndex].treasurePosition = newTreasurePosition;\n        emit TreasureMoved(newTreasurePosition, currentGameIndex);\n    }\n\n    /**\n     * @dev Moves the treasure to a random adjacent position.\n     * @notice This function is internal and should only be called from within the contract.\n     */\n    function _moveToRandomAdjacentPosition(uint256 randomWord) internal {\n        uint8 position = games[currentGameIndex].treasurePosition;\n        uint8[4] memory possiblePositions;\n        uint8 count = 0;\n\n        uint8 y = position / 10; // y axis of the board\n        uint8 x = position % 10; // x axis of the board\n\n        if (x != 0) {\n            possiblePositions[count++] = position - 1; // valid left\n        }\n\n        if (y != 0) {\n            possiblePositions[count++] = position - 10; // valid top\n        }\n\n        if (x != 9) {\n            possiblePositions[count++] = position + 1; // valid right\n        }\n\n        if (y != 9) {\n            possiblePositions[count++] = position + 10; // valid bottom\n        }\n\n        require(count > 0, \"No valid moves\");\n        uint8 newTreasurePosition = possiblePositions[randomWord % count];\n\n        games[currentGameIndex].treasurePosition = newTreasurePosition;\n        emit TreasureMoved(newTreasurePosition, currentGameIndex);\n    }\n\n    /**\n     * @notice Internal function to request random words from the randomness oracle.\n     * @dev This function requests a specified number of random words from the randomness oracle.\n     * @return requestId The ID of the randomness request, which can be used to track and manage the request status.\n     */\n    function _requestRandomWords(uint256 _currentGameIndex) internal returns (uint256 requestId) {\n        games[_currentGameIndex].treasureMoving = true;\n\n        (requestId,) =\n            requestRandomnessPayInNative(CALLBACK_GAS_LIMIT, _REQUEST_CONFIRMATIONS, _NUM_OF_RANDOM_WORDS, extraArgs);\n        request.requestId = requestId;\n        emit RequestSent(requestId);\n    }\n\n    /**\n     * @notice Resets the position of the treasure in the current game.\n     * @dev This function sets the treasure position based on a random word and reactivates the game.\n     * @param randomWord A random uint256 value used to determine the new treasure position.\n     * The treasure position is set as the modulo of this randomWord with GRID_SIZE.\n     * The function also emits a GameStarted event indicating the game has started with the new settings.\n     */\n    function _resetTreasurePosition(uint256 randomWord) internal {\n        request.newGame = false;\n        uint8 initialTreasurePosition = uint8(randomWord % GRID_SIZE);\n        games[currentGameIndex].treasurePosition = initialTreasurePosition;\n\n        emit GameStarted(currentGameIndex, games[currentGameIndex].tvl, initialTreasurePosition);\n    }\n\n    /**\n     * @dev Validate the player's new position based on the input direction.\n     * @param position current position of user in the game.\n     * @param move The direction of the move.\n     * @return nextPosition The validated new position.\n     */\n    function _newPosition(uint8 position, Directions move) internal pure returns (uint8 nextPosition) {\n        uint8 y = position / 10; // y axis of the board\n        uint8 x = position % 10; // x axis of the board\n\n        if (move == Directions.Left) {\n            nextPosition = (x == 0) ? 100 : position - 1;\n        } else if (move == Directions.Top) {\n            nextPosition = (y == 0) ? 100 : position - 10;\n        } else if (move == Directions.Right) {\n            nextPosition = (x == 9) ? 100 : position + 1;\n        } else if (move == Directions.Bottom) {\n            nextPosition = (y == 9) ? 100 : position + 10;\n        }\n\n        // 100 is a number outside bounds of the board, hence used to check invalid move\n        if (nextPosition == 100) {\n            revert InvalidMove(move, position);\n        }\n    }\n\n    /**\n     * @dev Generate a random position on the grid.\n     * @return uint8 The generated random position.\n     */\n    function _generateInitialRandomPosition() internal view returns (uint8) {\n        return uint8(uint256(keccak256(abi.encodePacked(block.timestamp, block.number))) % GRID_SIZE);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 1000
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}